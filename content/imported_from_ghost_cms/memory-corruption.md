Title: Practical Memory Corruption 0x1 - Stack-based Buffer Overflows
Date: 2022-12-12T21:23:54.000Z
Status: Draft

<h2 id="overview">Overview</h2><p>Recently I've got invested into the OSED (<em>Offensive Security Exploit Developer</em>) certification from Offensive Security.</p><p>For those who don't know, it's a highly renowned certification within the cyber-security field and it focuses on writing custom exploits and shellcode, and bypass security mitigations in Windows user-land.</p><p>You can check the course syllabus <a href="https://www.offensive-security.com/documentation/EXP301-syllabus.pdf">here</a>, but to give you a sneak peek, I'll list below some of the most interesting topics covered:</p><ul><li>Stack Overflows</li><li>DEP Bypass</li><li>Egg-hunters</li><li>ROP (Return Oriented Programming)</li><li>ASLRP Bypass</li></ul><p>At the moment, I'm focusing on memory corruption vulnerabilities; I think that's a good way to start things off. Looking for a roadmap on the Internet, I discovered a very good one in a <a href="https://t.co/4oN4VFXQ7C">presentation</a> made by <em>Mohammed Hassan</em>:</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="__GHOST_URL__/content/images/2022/12/image.png" class="kg-image" alt loading="lazy" width="1644" height="934" srcset="__GHOST_URL__/content/images/size/w600/2022/12/image.png 600w, __GHOST_URL__/content/images/size/w1000/2022/12/image.png 1000w, __GHOST_URL__/content/images/size/w1600/2022/12/image.png 1600w, __GHOST_URL__/content/images/2022/12/image.png 1644w" sizes="(min-width: 720px) 720px"><figcaption>The evolution of memory corruption exploit techniques &amp; mitigations</figcaption></figure><p>As you can see, the first memory corruption vulnerability discovered and exploited in the wild is the classic <em>Stack-based Buffer Overflow</em>, first documented in 1972: about half a century ago!</p><h2 id="about-the-vulnerability">About the vulnerability</h2><p>It's important to note that it's caused by the program reading too many bytes in a specific buffer.</p><p>For example, suppose you have a buffer of <code>100</code> bytes; if you use <code>memcpy</code> to copy <code>200</code> bytes into the buffer, what's going to happen?</p><p>The answer is... memory corruption: you will probably rewrite other bytes used by the program for other purposes, causing an error that will crash the program.</p><p>It really depends from program to program, but generally the error you'll see the most if the classic <code>SEGV</code> (Segmentation Fault), which is a good indicator of memory corruption vulnerabilities.</p><p>Attackers can exploit this vulnerability to write arbitrary data on the stack, and later redirect the execution of the program to run the malicious code.</p><p>Back in the past, programs used to set the stack area as <em>executable</em>, meaning you could execute shellcode stored on the stack e.g., stored in a local variable.</p><p>Nowayds, the stack is usually non-executable by default, thanks to the NX/DEP protections, so you need to exploit the vulnerability in a different way, but that's a story for another time.</p><h2 id="lets-practice">Let's practice!</h2><p>Alright, enough talking, it's time for practice. I'll take a <a href="https://cwe.mitre.org/data/definitions/121.html">simple example</a> from OWASP, so we can play along.</p><figure class="kg-card kg-code-card"><pre><code class="language-cpp">#include &lt;string.h&gt;

int main(int argc, char **argv)
{
    if (argc &gt; 1)
    {
        char buf[100];
        strcpy(buf, argv[1]);
    }
}</code></pre><figcaption>Example of code vulnerable to Buffer Overflow</figcaption></figure><p>The logic is quite straightforward: there's a buffer of <code>100</code> elements and the function <code>strcpy</code> is used for copying the characters of the first positional parameters into the buffer.</p><p>A problem arises when the string you're passing as positional parameter is longer than <code>100</code> characters: a memory corruption might happen if you overwrite anything important on the stack.</p><p>As an example, once you compile the code, you can cause a segmentation fault by passing a string longer than <code>100</code> characters as a positional parameter.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="__GHOST_URL__/content/images/2023/01/image.png" class="kg-image" alt loading="lazy" width="1221" height="732" srcset="__GHOST_URL__/content/images/size/w600/2023/01/image.png 600w, __GHOST_URL__/content/images/size/w1000/2023/01/image.png 1000w, __GHOST_URL__/content/images/2023/01/image.png 1221w" sizes="(min-width: 720px) 720px"><figcaption>Causing a segmentation fault</figcaption></figure><p>If you watch closely, you'll notice that passing a string slightly longer than the size of the buffer doesn't actually cause a segmentation fault. In fact, we manage to do this with 120 characters.</p><p>This might happen sometimes, depending where the return address of the function is stored on the stack. Anyway, I'll explain that in the next section.</p><h2 id="an-odd-memory-layout">An odd memory layout</h2><p>Since I'm talking about stack-based buffer overflow, I think it's important to mentioned an oddity regarding the memory of the stack section.</p><p>As it's shown below, while the memory normally grows from a lower address to a higher address, the stack does the opposite, growing towards lower memory addresses.</p><figure class="kg-card kg-image-card"><img src="__GHOST_URL__/content/images/2023/01/image-2.png" class="kg-image" alt loading="lazy" width="500" height="475"></figure><p>As an example, if we set the base of the stack to be <code>0xc000</code>:</p><ul><li>the first byte pushed on the stack will start from <code>0xc000</code></li><li>the second byte will start from <code>0xbfff</code></li><li>the third byte will start from <code>0xbffe</code></li><li>the fourth byte will start from <code>0xbffd</code></li></ul><p>... and so on, you probably got the gist.</p><h2 id="exploitation-theory">Exploitation Theory</h2><p>Consider what you can do with this vulnerability: you're able to write arbitrary data on the stack... cool, now what?</p><p>It's actually more than that, you can also hijack the execution of the program. Unfortunately, that's due to the location of the <em>instruction pointer</em>.</p><p>Suppose you have the following code:</p><figure class="kg-card kg-code-card"><pre><code class="language-cpp">int func_a(int param1, int param2)
{
    return param1 * param2;
}

int main()
{
    return func_a(10, 20);
}   </code></pre><figcaption>Sample code</figcaption></figure><p>When the <code>main</code> function calls <code>func_a</code>, the program will execute some specific assembly operations:</p><ul><li>use the <code>PUSH</code> instruction to place the first parameter (<code>10</code>) on the stack</li><li>use the <code>PUSH</code> instruction to place the second parameter (<code>20</code>) on the stack</li><li>use the <code>CALL</code> instruction instruction to execute this new function and, at the same time, place the memory address of the next instruction on the stack</li></ul><p>The assembly code should look like this:</p><pre><code class="language-asm">section .text

main:
    ; ...
    push 0x0000000a
    push 0x00000014
    call func_a
    ; ...</code></pre><p>Once the program enters the function <code>func_a</code>, the <code>stack</code> area should look like this:</p><!--kg-card-begin: markdown--><table>
<thead>
<tr>
<th>Offset</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>RETURN ADDRESS</td>
</tr>
<tr>
<td>-4</td>
<td>0x00000014</td>
</tr>
<tr>
<td>-8</td>
<td>0x0000000a</td>
</tr>
</tbody>
</table>
<!--kg-card-end: markdown--><p>There exist other assembly operations that are automatically performed, such as the creation of a new stack frame.</p><p>That's the reason you'll often see the notation <code>BP + N</code>, where <code>BP</code> is the base pointer, to access the function parameters, but I'm already writing too much, so I'll refrain from doing that.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="__GHOST_URL__/content/images/2023/01/image-3.png" class="kg-image" alt loading="lazy" width="1015" height="458" srcset="__GHOST_URL__/content/images/size/w600/2023/01/image-3.png 600w, __GHOST_URL__/content/images/size/w1000/2023/01/image-3.png 1000w, __GHOST_URL__/content/images/2023/01/image-3.png 1015w" sizes="(min-width: 720px) 720px"><figcaption>Example found on StackoOverflow by user <code>matteo-italia</code></figcaption></figure><p>After that function finishes executing all its code, it peforms the function epilogue, jumping to the <em>return address</em>.</p><p>Due to the return address being stored on the stack, and the fact that stack-based buffer overflows allow to overwrite data stored on the stack, it is possible to overwrite the return address, thus jumping to arbitrary memory addresses.</p><p>Usually attackers take advantage of this logic to jump to the memory address of some malicious code, or that of a hidden function; it depends on your goal.</p><h2 id="getting-a-shell">Getting a shell</h2><p>Suppose you're a malicious user who has just found a stack-based buffer overflow vulnerability in a 32-bit Linux binary, and your goal is to exploit it to get a shell.</p><blockquote>What do you do first?</blockquote><p>The first and the most important check in my opinion is to look at the NX bit: if the stack is not executable, you won't be able to exploit a buffer overflow using a stack-based technique, it simply isn't feasible.</p><p>For this, you can use the <code>readelf</code> binary. The following screenshot shows you that, without the <code>-z execstack</code> flag passed to <code>gcc</code>, the stack is going to be set as <em>readable</em> and <em>writable</em>, but not <strong>executable</strong>.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="__GHOST_URL__/content/images/2023/01/image-9.png" class="kg-image" alt loading="lazy" width="1072" height="451" srcset="__GHOST_URL__/content/images/size/w600/2023/01/image-9.png 600w, __GHOST_URL__/content/images/size/w1000/2023/01/image-9.png 1000w, __GHOST_URL__/content/images/2023/01/image-9.png 1072w" sizes="(min-width: 720px) 720px"><figcaption>Checking whether the stack is executable</figcaption></figure><p>To perform the attack successfully you need to set the stack as executable, so rember to do that before injecting payloads and wondering (like me) why they do not work.</p><p>The next step is to find the offset where the return address is stored on the stack. For this, you can use some pattern matching tools included in the Metasploit framework, namely <code>msf-pattern_create</code> and <code>msf-pattern_offset</code>.</p><p>First, you need to create the pattern:</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="__GHOST_URL__/content/images/2023/01/image-10.png" class="kg-image" alt loading="lazy" width="1907" height="152" srcset="__GHOST_URL__/content/images/size/w600/2023/01/image-10.png 600w, __GHOST_URL__/content/images/size/w1000/2023/01/image-10.png 1000w, __GHOST_URL__/content/images/size/w1600/2023/01/image-10.png 1600w, __GHOST_URL__/content/images/2023/01/image-10.png 1907w" sizes="(min-width: 720px) 720px"><figcaption>Pattern generation</figcaption></figure><p>After that, we're going to use a debugger (such as <code>gdb</code>) to analyze the behaviour of the program and the point where it crashes.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="__GHOST_URL__/content/images/2023/01/image-11.png" class="kg-image" alt loading="lazy" width="1315" height="843" srcset="__GHOST_URL__/content/images/size/w600/2023/01/image-11.png 600w, __GHOST_URL__/content/images/size/w1000/2023/01/image-11.png 1000w, __GHOST_URL__/content/images/2023/01/image-11.png 1315w" sizes="(min-width: 720px) 720px"><figcaption>Segmentation fault</figcaption></figure><p>In this case, the program failed to execute <code>RET</code> assembly instruction because it has to retrieve the memory address from the stack, and the register that points to the location of the stack (<code>ESP</code>) contains a junk value.</p><p>As a consequence, the program thinks that the top of the stack, where the return address is stored, is located at the address <code>0x64413360</code>, but it doesn't exist so it crashed instead.</p><p>The next step is to find the offset of this junk value, using <code>msf-pattern_offset</code>:</p><p> </p>
