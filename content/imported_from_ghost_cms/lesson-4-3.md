Title: Lesson 4.3 - APC Injection
Date: 2022-11-13T15:04:35.000Z
Status: Draft

<h2 id="theory">Theory</h2><h3 id="asynchronous-procedure-calls">Asynchronous Procedure Calls</h3><p>One way to perform process injection is to leverage <em>Asynchronous Procedure Calls</em> (APC). According to the official documentation provided by Microsoft:</p><blockquote>An <strong>asynchronous procedure call</strong> (APC) is a function that executes asynchronously in the context of a particular thread.</blockquote><blockquote>When an APC is queued to a thread, the system issues a software interrupt.</blockquote><blockquote>The next time the thread is scheduled, it will run the APC function. An APC generated by the system is called a <em>kernel-mode</em> APC.</blockquote><blockquote>An APC generated by an application is called a <em>user-mode</em> APC.</blockquote><blockquote>A thread must be in an alertable state to run a user-mode APC.</blockquote><p>There two key points in this description:</p><ol><li><strong>each thread has a queue for APC calls</strong>, so you can add an APC call to a specific thread of a specific process if you have the required privileges</li><li>for the APC to be executed, the thread must be in an <strong>alertable state</strong></li></ol><p>There are different functions you can use to force a thread to enter an <em>alertable state</em>:</p><blockquote>A thread enters an alertable state when it calls the <code>SleepEx</code>, <code>SignalObjectAndWait</code>, <code>MsgWaitForMultipleObjectsEx</code>, <code>WaitForMultipleObjectsEx</code>, or <code>WaitForSingleObjectEx</code> function.</blockquote><blockquote>If the wait is satisfied before the APC is queued, the thread is no longer in an alertable wait state so the APC function will not be executed.</blockquote><h3 id="queueuserapc">QueueUserAPC</h3><p>You can use the function <code>QueueUserAPC</code> in order to add an APC the queue of a specific thread:</p><blockquote>An application queues an APC to a thread by calling the <strong>QueueUserAPC</strong> function.</blockquote><blockquote>The calling thread specifies the address of an APC function in the call to QueueUserAPC.</blockquote><blockquote>The queuing of an APC is a request for the thread to call the APC function.</blockquote><p>Let's look at the function definition for a moment:</p><pre><code class="language-cpp">DWORD QueueUserAPC(
    [in] PAPCFUNC  pfnAPC,
    [in] HANDLE    hThread,
    [in] ULONG_PTR dwData
);</code></pre><p>As you can see, it uses three parameters:</p><ul><li><strong>pfnAPC</strong>, a pointer to an APC function (whose code resides inside the memory of the victim process)</li><li><strong>hThread</strong>, a handle to the victim thread</li><li><strong>dwData</strong>, a value passed to the APC function</li></ul><p>It's important to bear in mind that the code of the function, e.g. the shellcode we want to execute, must reside in the memory of the victim process.</p><p>If we wanted, for example, to execute the shellcode for a reverse shell or an implant, first we would need to use a write primitive in order to copy the shellcode inside the victim process.</p><p>After that, we could use the <em>QueueUserAPC</em> function to add the APC call to the queue of the interested thread.</p><h3 id="alertable-state">Alertable state</h3><p>As mentioned previously, a process enters an <em>alertable state</em> after it calls the following functions:</p><ul><li><code>SleepEx</code></li><li><code>SignalObjectAndWait</code></li><li><code>MsgWaitForMultipleObjectsEx</code></li><li><code>WaitForMultipleObjectsEx</code></li><li><code>WaitForSingleObjectEx</code></li></ul><p>An alternative is to use the Native API of Windows, in particular the syscall <code>NtAlertThread</code>.</p><h2 id="practice">Practice</h2><p>Here's the final code:</p>
